<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Molecule Merge</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f5;
            flex-direction: column;
            color: #333;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #fff;
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 500px;
        }

        h1 {
            color: #4a4a4a;
            margin-bottom: 0.5rem;
        }

        .info-bar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0 1rem;
            font-weight: 700;
        }

        .target-molecule {
            background-color: #e2e8f0;
            padding: 0.5rem 1rem;
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

        .target-molecule:hover {
            transform: translateY(-2px);
        }
        
        #game-canvas {
            border: 2px solid #a0a0a0;
            background-color: #f8f8f8;
            border-radius: 0.75rem;
            touch-action: none; /* Prevents default browser actions on touch */
        }

        .controls {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
        }

        .game-btn, .column-btn {
            background-color: #6366f1;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 700;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
            transition: all 0.2s ease-in-out;
            touch-action: manipulation;
        }
        
        .game-btn:hover, .column-btn:hover {
            background-color: #4f46e5;
            transform: translateY(-2px);
        }

        .game-btn:active, .column-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(99, 102, 241, 0.5);
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out;
            z-index: 1000;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }

        .modal-content h2 {
            margin-top: 0;
        }

        .modal-content button {
            background-color: #f97316;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 700;
            margin-top: 1rem;
        }

        .rules-content p, .formula-content p {
            text-align: left;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>

<div class="game-container">
    <h1>Molecule Merge</h1>
    <div class="info-bar">
        <span>Level: <span id="level">1</span></span>
        <div class="target-molecule">
            Target: <span id="target-molecule"></span>
        </div>
    </div>
    <canvas id="game-canvas"></canvas>
    <div class="controls" id="controls">
        <button class="game-btn" id="rules-button">Rules</button>
    </div>
</div>

<div class="modal-overlay" id="gameModal">
    <div class="modal-content">
        <h2 id="modal-title"></h2>
        <div id="modal-body"></div>
        <button id="modal-button"></button>
    </div>
</div>

<script>
    // Constants for game board and elements
    const GRID_SIZE = 5;
    const TILE_SIZE = 80;
    const PADDING = 10;
    const TILE_RADIUS = 10;
    const FONT_SIZE = 24;

    // Canvas and context
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    canvas.width = GRID_SIZE * (TILE_SIZE + PADDING) + PADDING;
    canvas.height = GRID_SIZE * (TILE_SIZE + PADDING) + PADDING;

    // Game state variables
    let grid = [];
    let currentLevel = 1;
    let targetMoleculesFormed = 0;
    let targetMolecule;
    let nextTile = '';
    let isGameOver = false;
    let isAnimating = false;
    let mergingTiles = [];

    // Elements and their properties
    const ELEMENTS = {
        H: { color: '#ffffff', textColor: '#444', name: 'Hydrogen' },
        O: { color: '#ef4444', textColor: '#fff', name: 'Oxygen' },
        C: { color: '#6b7280', textColor: '#fff', name: 'Carbon' },
        N: { color: '#3b82f6', textColor: '#fff', name: 'Nitrogen' },
        S: { color: '#f59e0b', textColor: '#fff', name: 'Sulfur' },
        Cl: { color: '#16a34a', textColor: '#fff', name: 'Chlorine' },
        'ðŸŽ²': { color: '#a855f7', textColor: '#fff', name: 'Wildcard Dice' } // Special wildcard tile, now a dice emoji
    };
    
    // Level configurations
    const LEVELS = {
        1: {
            target: { H: 2, O: 1 },
            elements: ['H', 'O'],
            name: 'Water',
            formula: '$H_2O$',
            targetCount: 3,
            wildcardChance: 0
        },
        2: {
            target: { C: 1, O: 2 },
            elements: ['H', 'O', 'C'],
            name: 'Carbon Dioxide',
            formula: '$CO_2$',
            targetCount: 2,
            wildcardChance: 0
        },
        3: {
            target: { C: 1, O: 1 },
            elements: ['H', 'O', 'C', 'N'],
            name: 'Carbon Monoxide',
            formula: '$CO$',
            targetCount: 3,
            wildcardChance: 0
        },
        4: {
            target: { S: 1, O: 3 },
            elements: ['H', 'O', 'C', 'N', 'S'],
            name: 'Sulfur Trioxide',
            formula: '$SO_3$',
            targetCount: 2,
            wildcardChance: 0
        },
        5: {
            target: { N: 1, H: 3 },
            elements: ['H', 'O', 'C', 'N', 'S', 'Cl'],
            name: 'Ammonia',
            formula: '$NH_3$',
            targetCount: 3,
            wildcardChance: 0.1
        },
        6: {
            target: { C: 1, H: 4 },
            elements: ['H', 'O', 'C', 'N', 'S', 'Cl'],
            name: 'Methane',
            formula: '$CH_4$',
            targetCount: 2,
            wildcardChance: 0.1
        },
        7: {
            target: { H: 2, O: 2 },
            elements: ['H', 'O', 'C', 'N', 'S', 'Cl'],
            name: 'Hydrogen Peroxide',
            formula: '$H_2O_2$',
            targetCount: 3,
            wildcardChance: 0.15
        },
        8: {
            target: { S: 1, O: 2 },
            elements: ['H', 'O', 'C', 'N', 'S', 'Cl'],
            name: 'Sulfur Dioxide',
            formula: '$SO_2$',
            targetCount: 2,
            wildcardChance: 0.15
        },
        9: {
            target: { N: 1, H: 3 },
            elements: ['H', 'O', 'C', 'N', 'S', 'Cl'],
            name: 'Ammonia',
            formula: '$NH_3$',
            targetCount: 3,
            wildcardChance: 0.2
        },
        10: {
            target: { C: 1, Cl: 4 },
            elements: ['H', 'O', 'C', 'N', 'S', 'Cl'],
            name: 'Carbon Tetrachloride',
            formula: '$CCl_4$',
            targetCount: 2,
            wildcardChance: 0.2
        }
    };
    
    // DOM elements
    const levelDisplay = document.getElementById('level');
    const targetMoleculeDisplay = document.getElementById('target-molecule');
    const rulesButton = document.getElementById('rules-button');
    const gameModal = document.getElementById('gameModal');
    const modalTitle = document.getElementById('modal-title');
    const modalBody = document.getElementById('modal-body');
    const modalButton = document.getElementById('modal-button');

    /**
     * Initializes a new game or level.
     */
    function initGame() {
        grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
        targetMoleculesFormed = 0;
        isGameOver = false;
        isAnimating = false;
        
        const levelConfig = LEVELS[currentLevel] || LEVELS[1];
        targetMolecule = levelConfig.target;
        targetMoleculeDisplay.textContent = levelConfig.name;
        levelDisplay.textContent = currentLevel;
        
        generateNextTile();
        
        hideModal();
        draw();
    }

    /**
     * Draws the entire game state on the canvas.
     */
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#e5e7eb';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let row = 0; row < GRID_SIZE; row++) {
            for (let col = 0; col < GRID_SIZE; col++) {
                drawGridCell(col, row);
                if (grid[row][col]) {
                    drawTile(col, row, grid[row][col]);
                }
            }
        }
        
        drawNextTilePreview();
    }

    /**
     * Draws a single grid cell.
     * @param {number} col - The column index.
     * @param {number} row - The row index.
     */
    function drawGridCell(col, row) {
        ctx.fillStyle = '#d1d5db';
        ctx.strokeStyle = '#9ca3af';
        ctx.lineWidth = 1;
        const x = col * (TILE_SIZE + PADDING) + PADDING;
        const y = row * (TILE_SIZE + PADDING) + PADDING;
        ctx.beginPath();
        ctx.roundRect(x, y, TILE_SIZE, TILE_SIZE, TILE_RADIUS);
        ctx.fill();
        ctx.stroke();
    }

    /**
     * Draws a tile on the canvas.
     * @param {number} col - The column index.
     * @param {number} row - The row index.
     * @param {string} element - The element symbol (e.g., 'H', 'O', 'ðŸŽ²').
     * @param {number} [scale=1] - The scale of the tile for animation.
     */
    function drawTile(col, row, element, scale = 1) {
        const x = col * (TILE_SIZE + PADDING) + PADDING;
        const y = row * (TILE_SIZE + PADDING) + PADDING;
        
        const elementData = ELEMENTS[element];
        const tileScaledSize = TILE_SIZE * scale;
        const scaledX = x + (TILE_SIZE - tileScaledSize) / 2;
        const scaledY = y + (TILE_SIZE - tileScaledSize) / 2;

        ctx.fillStyle = elementData.color;
        ctx.beginPath();
        ctx.roundRect(scaledX, scaledY, tileScaledSize, tileScaledSize, TILE_RADIUS * scale);
        ctx.fill();
        
        ctx.fillStyle = elementData.textColor;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Handle dice emoji separately for better rendering
        if (element === 'ðŸŽ²') {
            ctx.font = `bold ${FONT_SIZE * scale * 1.5}px sans-serif`;
            ctx.fillText(element, scaledX + tileScaledSize / 2, scaledY + tileScaledSize / 2 + 5);
        } else {
            ctx.font = `bold ${FONT_SIZE * scale}px 'Inter'`;
            ctx.fillText(element, scaledX + tileScaledSize / 2, scaledY + tileScaledSize / 2);
        }
    }
    
    /**
     * Draws the preview of the next tile to drop.
     */
    function drawNextTilePreview() {
        const x = canvas.width / 2;
        const y = PADDING / 2;
        
        ctx.font = `bold ${FONT_SIZE * 0.8}px 'Inter'`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#444';
        ctx.fillText('Next', x, y - 20);
        
        const previewSize = TILE_SIZE * 0.7;
        const elementData = ELEMENTS[nextTile];
        
        ctx.fillStyle = elementData.color;
        ctx.beginPath();
        ctx.roundRect(x - previewSize / 2, y + 5, previewSize, previewSize, TILE_RADIUS * 0.7);
        ctx.fill();
        
        ctx.fillStyle = elementData.textColor;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Handle dice emoji separately for better rendering
        if (nextTile === 'ðŸŽ²') {
            ctx.font = `bold ${FONT_SIZE * 0.7 * 1.5}px sans-serif`;
            ctx.fillText(nextTile, x, y + 5 + previewSize / 2 + 5);
        } else {
            ctx.font = `bold ${FONT_SIZE * 0.7}px 'Inter'`;
            ctx.fillText(nextTile, x, y + 5 + previewSize / 2);
        }
    }

    /**
     * Generates a random element for the next tile based on the current level.
     */
    function generateNextTile() {
        const levelConfig = LEVELS[currentLevel] || LEVELS[1];
        const elements = levelConfig.elements;
        const wildcardChance = levelConfig.wildcardChance;

        if (Math.random() < wildcardChance) {
            nextTile = 'ðŸŽ²';
        } else {
            const randomIndex = Math.floor(Math.random() * elements.length);
            nextTile = elements[randomIndex];
        }
    }
    
    /**
     * Drops the current tile into the specified column.
     * @param {number} col - The column to drop the tile into.
     */
    function dropTile(col) {
        if (isGameOver || isAnimating) return;
        if (col < 0 || col >= GRID_SIZE) return;

        let row = GRID_SIZE - 1;
        while (row >= 0 && grid[row][col] !== null) {
            row--;
        }
        
        if (row < 0) {
            endGame('Column is full!');
            return;
        }
        
        grid[row][col] = nextTile;
        generateNextTile();
        
        checkAndRemoveMolecules();
        draw();
        
        if (isGridFull()) {
            endGame('Grid is full!');
        }
    }
    
    /**
     * Checks if the entire grid is full of tiles.
     * @returns {boolean} True if the grid is full, false otherwise.
     */
    function isGridFull() {
        for (let row = 0; row < GRID_SIZE; row++) {
            for (let col = 0; col < GRID_SIZE; col++) {
                if (grid[row][col] === null) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Checks for molecule formations and removes them from the grid.
     */
    function checkAndRemoveMolecules() {
        const levelConfig = LEVELS[currentLevel] || LEVELS[1];
        const target = levelConfig.target;
        let moleculesFound = 0;
        const tilesToRemove = new Set();
        mergingTiles = [];

        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (grid[r][c] !== null) {
                    const matches = findMatchingMolecule(r, c, target);
                    if (matches) {
                        moleculesFound++;
                        showMessage('Molecule Found!', `You successfully formed ${levelConfig.name}!`, 'OK', hideModal);
                        matches.forEach(tile => {
                            const key = `${tile.r},${tile.c}`;
                            if (!tilesToRemove.has(key)) {
                                tilesToRemove.add(key);
                                mergingTiles.push({ r: tile.r, c: tile.c, scale: 1, element: grid[tile.r][tile.c] });
                            }
                        });
                    }
                }
            }
        }
        
        if (mergingTiles.length > 0) {
            isAnimating = true;
            targetMoleculesFormed += moleculesFound;
            startMergeAnimation();
        } else {
            gravity();
            draw();
        }
    }
    
    /**
     * Starts the animation for merging tiles.
     */
    function startMergeAnimation() {
        const animationDuration = 500; // milliseconds
        const startTime = Date.now();

        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = elapsed / animationDuration;

            if (progress >= 1) {
                isAnimating = false;
                // Remove tiles from grid and apply gravity after animation
                mergingTiles.forEach(tile => {
                    grid[tile.r][tile.c] = null;
                });
                mergingTiles = [];
                gravity();
                draw();
                
                // Check for level win condition
                const levelConfig = LEVELS[currentLevel] || LEVELS[1];
                if (targetMoleculesFormed >= levelConfig.targetCount) {
                    winLevel();
                }
                return;
            }

            // Draw the animation frame
            draw();
            mergingTiles.forEach(tile => {
                const newScale = 1 - progress;
                drawTile(tile.c, tile.r, tile.element, newScale);
            });

            requestAnimationFrame(animate);
        }

        animate();
    }

    /**
     * Moves tiles down to fill empty spaces.
     */
    function gravity() {
        for (let c = 0; c < GRID_SIZE; c++) {
            let emptyRow = GRID_SIZE - 1;
            for (let r = GRID_SIZE - 1; r >= 0; r--) {
                if (grid[r][c] !== null) {
                    if (r !== emptyRow) {
                        grid[emptyRow][c] = grid[r][c];
                        grid[r][c] = null;
                    }
                    emptyRow--;
                }
            }
        }
    }

    /**
     * Finds a matching molecule starting from a given cell using a Depth-First Search.
     * @param {number} startRow - The starting row.
     * @param {number} startCol - The starting column.
     * @param {Object} target - The target molecule composition.
     * @returns {Array|null} An array of tile coordinates if a match is found, otherwise null.
     */
    function findMatchingMolecule(startRow, startCol, target) {
        const visited = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(false));
        const foundTiles = [];

        function search(row, col, elementsFound) {
            if (foundTiles.length === Object.values(target).reduce((sum, val) => sum + val, 0)) {
                for (const element in target) {
                    if ((elementsFound[element] || 0) !== target[element]) {
                        return false;
                    }
                }
                return true;
            }

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;

                if (newRow >= 0 && newRow < GRID_SIZE && newCol >= 0 && newCol < GRID_SIZE && !visited[newRow][newCol]) {
                    const newElement = grid[newRow][newCol];
                    if (newElement === null) continue;

                    if (newElement === 'ðŸŽ²') {
                        for (const targetElement in target) {
                            if ((elementsFound[targetElement] || 0) < target[targetElement]) {
                                visited[newRow][newCol] = true;
                                foundTiles.push({ r: newRow, c: newCol });
                                elementsFound[targetElement] = (elementsFound[targetElement] || 0) + 1;
                                
                                if (search(newRow, newCol, elementsFound)) {
                                    return true;
                                }

                                foundTiles.pop();
                                elementsFound[targetElement]--;
                                visited[newRow][newCol] = false;
                            }
                        }
                    } else if (target[newElement] && (elementsFound[newElement] || 0) < target[newElement]) {
                        visited[newRow][newCol] = true;
                        foundTiles.push({ r: newRow, c: newCol });
                        elementsFound[newElement] = (elementsFound[newElement] || 0) + 1;
                        
                        if (search(newRow, newCol, elementsFound)) {
                            return true;
                        }

                        foundTiles.pop();
                        elementsFound[newElement]--;
                        visited[newRow][newCol] = false;
                    }
                }
            }
            return false;
        }

        const startElement = grid[startRow][startCol];
        if (!startElement) return null;

        const initialElements = {};
        if (startElement === 'ðŸŽ²') {
            for (const targetElement in target) {
                if ((initialElements[targetElement] || 0) < target[targetElement]) {
                    initialElements[targetElement] = (initialElements[targetElement] || 0) + 1;
                    visited[startRow][startCol] = true;
                    foundTiles.push({ r: startRow, c: startCol });
                    if (search(startRow, startCol, initialElements)) {
                        return foundTiles;
                    }
                    foundTiles.pop();
                    initialElements[targetElement]--;
                    visited[startRow][startCol] = false;
                }
            }
        } else if (target[startElement]) {
            initialElements[startElement] = 1;
            visited[startRow][startCol] = true;
            foundTiles.push({ r: startRow, c: startCol });
            if (search(startRow, startCol, initialElements)) {
                return foundTiles;
            }
        }
        
        return null;
    }

    /**
     * Shows a modal with custom content.
     * @param {string} title - The title of the modal.
     * @param {string} bodyContent - The HTML content for the modal body.
     * @param {string} buttonText - The text for the modal button.
     * @param {Function} buttonAction - The function to call when the button is clicked.
     */
    function showMessage(title, bodyContent, buttonText, buttonAction) {
        modalTitle.textContent = title;
        modalBody.innerHTML = bodyContent;
        modalButton.textContent = buttonText;
        modalButton.onclick = buttonAction;
        gameModal.classList.add('active');
    }

    /**
     * Hides the modal.
     */
    function hideModal() {
        gameModal.classList.remove('active');
    }
    
    /**
     * Ends the game and displays a message.
     * @param {string} message - The message to display.
     */
    function endGame(message) {
        isGameOver = true;
        showMessage('Game Over!', message, 'Play Again', resetGame);
    }
    
    /**
     * Resets the game to level 1.
     */
    function resetGame() {
        currentLevel = 1;
        initGame();
    }

    /**
     * Advances to the next level.
     */
    function winLevel() {
        currentLevel++;
        if (currentLevel > Object.keys(LEVELS).length) {
            currentLevel = 1; // Loop back to the beginning
            showMessage('You Win!', 'You have completed all levels! Starting over.', 'Play Again', initGame);
        } else {
            showMessage('Level Complete!', 'Get ready for the next challenge.', 'Next Level', nextLevel);
        }
    }
    
    /**
     * Moves to the next level after winning.
     */
    function nextLevel() {
        initGame();
    }

    /**
     * Shows the rules pop-up.
     */
    function showRules() {
        const rulesHtml = `
            <p><strong>Goal:</strong> Form the target molecule on the grid by dropping atoms into the columns.</p>
            <p><strong>How to Play:</strong> Click anywhere in a column to release an atom into that column. Atoms fall to the lowest empty spot.</p>
            <p><strong>Forming Molecules:</strong> When you connect the correct atoms for the target molecule, they will disappear. The remaining atoms will fall to fill the empty spaces.</p>
            <p><strong>Wildcard Tile:</strong> The purple 'ðŸŽ²' tile can act as any element to help you complete a molecule.</p>
            <p><strong>Game Over:</strong> The game ends if any column fills up completely to the top.</p>
        `;
        showMessage('Rules', rulesHtml, 'Got it!', hideModal);
    }

    /**
     * Shows the chemical formula pop-up for the current level.
     */
    function showFormula() {
        const levelConfig = LEVELS[currentLevel] || LEVELS[1];
        const formula = levelConfig.formula;
        let body = `<p>The target molecule is <strong>${levelConfig.name}</strong>, with the chemical formula <strong>${formula}</strong>.</p>
                    <p>You need to connect the following atoms:</p>
                    <ul>`;
        for (const element in levelConfig.target) {
            body += `<li>${levelConfig.target[element]} x ${ELEMENTS[element].name} (${element})</li>`;
        }
        body += `</ul>`;
        showMessage('Chemical Formula', body, 'OK', hideModal);
    }
    
    // Initial call to start the game
    window.onload = function() {
        initGame();
    };

    // Add event listeners for the new buttons
    rulesButton.addEventListener('click', showRules);
    targetMoleculeDisplay.addEventListener('click', showFormula);

    // Add click listener to the canvas for dropping tiles
    canvas.addEventListener('click', (e) => {
        if (isGameOver || isAnimating) return;
        const x = e.offsetX;
        const col = Math.floor((x - PADDING) / (TILE_SIZE + PADDING));
        dropTile(col);
    });

    // Responsive canvas resizing
    window.addEventListener('resize', () => {
        const containerWidth = document.querySelector('.game-container').offsetWidth;
        const newSize = Math.min(containerWidth, 500);
        canvas.width = newSize;
        canvas.height = newSize;
        draw();
    });
</script>

</body>
</html>

