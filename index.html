<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Molecule Merge by Azuberkelium</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --primary-color: #4A90E2;
            --secondary-color: #50E3C2;
            --dark-bg: #2C3E50;
            --light-bg: #ECF0F1;
            --text-color: #ECF0F1;
            /* Updated Element Colors for better clarity and uniqueness */
            --element-H: #B3E5FC; /* Light Sky Blue */
            --element-O: #EF5350; /* Red */
            --element-C: #263238; /* Dark Gray */
            --element-N: #673AB7; /* Deep Purple */
            --element-Na: #FFB74D; /* Light Orange */
            --element-Cl: #8BC34A; /* Green */
            --element-S: #FFEB3B; /* Yellow */
            --element-Ca: #795548; /* Brown */
            --element-Fe: #D32F2F; /* Rusty Red */
            --element-K: #E91E63; /* Pink Magenta */
            --element-Mg: #CDDC39; /* Lime Green */
            --element-Al: #BDBDBD; /* Silver Gray */
            --element-P: #FF5722; /* Deep Orange */
            --element-Si: #9E9E9E; /* Medium Gray */
            --element-He: #00FFFF;
            --element-Ne: #ADD8E6;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            border-radius: 15px;
            background-color: #34495E;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }

        .game-main {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.5em;
            margin: 0;
            color: var(--secondary-color);
        }

        .score-display {
            font-size: 1.5em;
            font-weight: bold;
            margin: 10px 0;
            color: var(--primary-color);
        }

        #gameCanvas {
            border: 5px solid #2C3E50;
            border-radius: 10px;
            background-color: #ECF0F1;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            cursor: pointer;
        }
        
        #nextElementCanvas {
            width: 80px;
            height: 80px;
            border: 5px solid #2C3E50;
            border-radius: 10px;
            background-color: #ECF0F1;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        button#newGameBtn {
            background-color: var(--secondary-color);
            color: var(--dark-bg);
        }

        button#newGameBtn:hover {
            background-color: #40C2A7;
            transform: translateY(-2px);
        }

        #soundBtn {
            width: 45px;
            height: 45px;
            background-color: #8E44AD;
            color: var(--text-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #soundBtn:hover {
            background-color: #9B59B6;
        }

        .molecule-book {
            width: 300px;
            background-color: #2C3E50;
            border-radius: 10px;
            padding: 20px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
            max-height: 70vh;
        }

        .molecule-book h2 {
            margin-top: 0;
            font-size: 1.5em;
            color: var(--secondary-color);
            text-align: center;
        }

        .molecule-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        .molecule-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #34495E;
            transition: background-color 0.2s;
        }
        
        .molecule-item:last-child {
            border-bottom: none;
        }

        .molecule-item:hover {
            background-color: #34495E;
        }

        .molecule-name {
            font-weight: bold;
        }

        .molecule-symbol {
            font-style: italic;
            font-weight: normal;
        }
        
        .tally {
            background-color: #2C3E50;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
            font-weight: bold;
            color: var(--secondary-color);
        }

        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(44, 62, 80, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        /* Merging Animation */
        @keyframes merge-pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .element-H { background-color: var(--element-H); color: #000; }
        .element-O { background-color: var(--element-O); color: #fff; }
        .element-C { background-color: var(--element-C); color: #fff; }
        .element-N { background-color: var(--element-N); color: #fff; }
        .element-Na { background-color: var(--element-Na); color: #fff; }
        .element-Cl { background-color: var(--element-Cl); color: #fff; }
        .element-S { background-color: var(--element-S); color: #000; }
        .element-Ca { background-color: var(--element-Ca); color: #fff; }
        .element-Fe { background-color: var(--element-Fe); color: #fff; }
        .element-K { background-color: var(--element-K); color: #fff; }
        .element-Mg { background-color: var(--element-Mg); color: #fff; }
        .element-Al { background-color: var(--element-Al); color: #fff; }
        .element-P { background-color: var(--element-P); color: #fff; }
        .element-Si { background-color: var(--element-Si); color: #fff; }
        .element-He { background-color: var(--element-He); color: #000; }
        .element-Ne { background-color: var(--element-Ne); color: #000; }


        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }

            .molecule-book {
                width: 100%;
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <!-- Molecule Book -->
    <div class="molecule-book">
        <h2>Molecule Book</h2>
        <ul id="moleculeList" class="molecule-list">
            <!-- Molecules will be dynamically added here -->
        </ul>
    </div>

    <!-- Game Main Area -->
    <div class="game-main">
        <div class="header">
            <h1>Molecule Merge</h1>
            <div id="scoreDisplay" class="score-display">Score: 0</div>
        </div>
        
        <label for="nextElementCanvas" style="font-size:1.2em; font-weight:bold; margin-bottom: 5px;">Next:</label>
        <canvas id="nextElementCanvas" width="80" height="80"></canvas>
        <canvas id="gameCanvas"></canvas>
        
        <div class="controls">
            <button id="newGameBtn">New Game</button>
            <button id="soundBtn"><i class="fas fa-volume-up"></i></button>
        </div>
    </div>
</div>

<div id="messageBox" class="message-box"></div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- Game Setup ---
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const nextElementCanvas = document.getElementById('nextElementCanvas');
        const nextElementCtx = nextElementCanvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const moleculeList = document.getElementById('moleculeList');
        const newGameBtn = document.getElementById('newGameBtn');
        const soundBtn = document.getElementById('soundBtn');
        const messageBox = document.getElementById('messageBox');

        const GRID_ROWS = 5;
        const GRID_COLS = 5;
        const CELL_SIZE = 80;
        const DROP_SPEED = 2; // Pixels per frame
        const ANIMATION_DURATION = 500; // ms

        gameCanvas.width = GRID_COLS * CELL_SIZE;
        gameCanvas.height = GRID_ROWS * CELL_SIZE;

        let grid = [];
        let score = 0;
        let activeElement = null;
        let nextElement = null;
        let dropColumn = -1;
        let dropY = 0;
        let isDropping = false;
        let isMerging = false;
        let soundOn = true;

        // Web Audio API for simple sound
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let oscillator = null;

        function playSound() {
            if (!soundOn) return;
            if (oscillator) {
                oscillator.stop();
                oscillator.disconnect();
            }
            oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.value = 440; // A4 note
            oscillator.connect(audioContext.destination);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1); // Play for 100ms
        }

        // Available Elements
        const elements = [
            { symbol: 'H', name: 'Hydrogen', color: 'var(--element-H)' },
            { symbol: 'O', name: 'Oxygen', color: 'var(--element-O)' },
            { symbol: 'C', name: 'Carbon', color: 'var(--element-C)' },
            { symbol: 'N', name: 'Nitrogen', color: 'var(--element-N)' },
            { symbol: 'S', name: 'Sulfur', color: 'var(--element-S)' },
            { symbol: 'Cl', name: 'Chlorine', color: 'var(--element-Cl)' },
            { symbol: 'Na', name: 'Sodium', color: 'var(--element-Na)' },
            { symbol: 'P', name: 'Phosphorus', color: 'var(--element-P)' },
            { symbol: 'K', name: 'Potassium', color: 'var(--element-K)' },
            { symbol: 'Ca', name: 'Calcium', color: 'var(--element-Ca)' },
            { symbol: 'Fe', name: 'Iron', color: 'var(--element-Fe)' },
            { symbol: 'Mg', name: 'Magnesium', color: 'var(--element-Mg)' },
            { symbol: 'Al', name: 'Aluminium', color: 'var(--element-Al)' },
            { symbol: 'Si', name: 'Silicon', color: 'var(--element-Si)' },
        ];

        // 25 common, stable molecules
        const molecules = [
            { name: 'Water', formula: 'H₂O', elements: { 'H': 2, 'O': 1 }, points: 50 },
            { name: 'Carbon Dioxide', formula: 'CO₂', elements: { 'C': 1, 'O': 2 }, points: 70 },
            { name: 'Methane', formula: 'CH₄', elements: { 'C': 1, 'H': 4 }, points: 80 },
            { name: 'Ammonia', formula: 'NH₃', elements: { 'N': 1, 'H': 3 }, points: 80 },
            { name: 'Sulfuric Acid', formula: 'H₂SO₄', elements: { 'H': 2, 'S': 1, 'O': 4 }, points: 150 },
            { name: 'Sodium Chloride', formula: 'NaCl', elements: { 'Na': 1, 'Cl': 1 }, points: 60 },
            { name: 'Glucose', formula: 'C₆H₁₂O₆', elements: { 'C': 6, 'H': 12, 'O': 6 }, points: 300 },
            { name: 'Hydrogen Peroxide', formula: 'H₂O₂', elements: { 'H': 2, 'O': 2 }, points: 70 },
            { name: 'Baking Soda', formula: 'NaHCO₃', elements: { 'Na': 1, 'H': 1, 'C': 1, 'O': 3 }, points: 120 },
            { name: 'Calcium Carbonate', formula: 'CaCO₃', elements: { 'Ca': 1, 'C': 1, 'O': 3 }, points: 140 },
            { name: 'Ethanol', formula: 'C₂H₅OH', elements: { 'C': 2, 'H': 6, 'O': 1 }, points: 100 },
            { name: 'Table Sugar', formula: 'C₁₂H₂₂O₁₁', elements: { 'C': 12, 'H': 22, 'O': 11 }, points: 500 },
            { name: 'Nitrous Oxide', formula: 'N₂O', elements: { 'N': 2, 'O': 1 }, points: 90 },
            { name: 'Acetone', formula: 'C₃H₆O', elements: { 'C': 3, 'H': 6, 'O': 1 }, points: 110 },
            { name: 'Urea', formula: 'CH₄N₂O', elements: { 'C': 1, 'H': 4, 'N': 2, 'O': 1 }, points: 130 },
            { name: 'Ozone', formula: 'O₃', elements: { 'O': 3 }, points: 40 },
            { name: 'Limestone', formula: 'CaCO₃', elements: { 'Ca': 1, 'C': 1, 'O': 3 }, points: 140 }, // Same as Calcium Carbonate
            { name: 'Hydrochloric Acid', formula: 'HCl', elements: { 'H': 1, 'Cl': 1 }, points: 50 },
            { name: 'Acetic Acid', formula: 'C₂H₄O₂', elements: { 'C': 2, 'H': 4, 'O': 2 }, points: 90 },
            { name: 'Ammonium Chloride', formula: 'NH₄Cl', elements: { 'N': 1, 'H': 4, 'Cl': 1 }, points: 110 },
            { name: 'Magnesium Oxide', formula: 'MgO', elements: { 'Mg': 1, 'O': 1 }, points: 70 },
            { name: 'Potassium Nitrate', formula: 'KNO₃', elements: { 'K': 1, 'N': 1, 'O': 3 }, points: 120 },
            { name: 'Silica', formula: 'SiO₂', elements: { 'Si': 1, 'O': 2 }, points: 100 },
            { name: 'Iron Oxide', formula: 'Fe₂O₃', elements: { 'Fe': 2, 'O': 3 }, points: 180 },
            { name: 'Formaldehyde', formula: 'CH₂O', elements: { 'C': 1, 'H': 2, 'O': 1 }, points: 80 }
        ];

        let moleculeCounts = {};
        molecules.forEach(mol => {
            moleculeCounts[mol.formula] = 0;
        });

        // --- Game Functions ---
        function initGame() {
            grid = Array.from({ length: GRID_ROWS }, () =>
                Array.from({ length: GRID_COLS }, () => null)
            );
            score = 0;
            scoreDisplay.textContent = `Score: ${score}`;
            isDropping = false;
            isMerging = false;
            activeElement = null;
            nextElement = null;
            
            molecules.forEach(mol => {
                moleculeCounts[mol.formula] = 0;
            });
            updateMoleculeBook();

            generateNextElement();
            requestAnimationFrame(draw);
        }

        function updateMoleculeBook() {
            moleculeList.innerHTML = '';
            molecules.forEach(mol => {
                const li = document.createElement('li');
                li.className = 'molecule-item';
                li.innerHTML = `
                    <div class="molecule-info">
                        <span class="molecule-name">${mol.name}</span>
                        <span class="molecule-symbol">${mol.formula}</span>
                    </div>
                    <div class="tally" id="tally-${mol.formula}">${moleculeCounts[mol.formula]}</div>
                `;
                moleculeList.appendChild(li);
            });
        }
        
        function updateTally(formula) {
            moleculeCounts[formula]++;
            const tallyElement = document.getElementById(`tally-${formula}`);
            if (tallyElement) {
                tallyElement.textContent = moleculeCounts[formula];
            }
        }

        function generateNextElement() {
            const randomIndex = Math.floor(Math.random() * elements.length);
            nextElement = { ...elements[randomIndex], y: 0 };
            if (!activeElement) {
                activeElement = nextElement;
                generateNextElement();
            }
        }

        function draw() {
            // Clear game canvas
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            // Draw next element on its own canvas
            drawNextElement();

            // Draw grid
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    gameCtx.strokeStyle = '#BDC3C7';
                    gameCtx.strokeRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }

            // Draw elements in the grid
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const element = grid[r][c];
                    if (element) {
                        drawElement(gameCtx, element.symbol, element.color, c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw active element falling from the top
            if (isDropping && activeElement) {
                const x = dropColumn * CELL_SIZE;
                drawElement(gameCtx, activeElement.symbol, activeElement.color, x, dropY, CELL_SIZE);
            }
            
            requestAnimationFrame(draw);
        }
        
        function drawNextElement() {
            nextElementCtx.clearRect(0, 0, nextElementCanvas.width, nextElementCanvas.height);
            if (nextElement) {
                const drawSize = nextElementCanvas.width;
                drawElement(nextElementCtx, nextElement.symbol, nextElement.color, 0, 0, drawSize);
            }
        }

        /**
         * Resolves a CSS variable string to its corresponding hex color value.
         * @param {string} varName The name of the CSS variable, e.g., 'var(--element-H)'.
         * @returns {string} The resolved hex color string, e.g., '#B3E5FC'.
         */
        function resolveCssVar(varName) {
            if (varName.startsWith('var(')) {
                return getComputedStyle(document.documentElement).getPropertyValue(varName.match(/--[\w-]+/)[0]).trim();
            }
            return varName;
        }

        function drawElement(ctx, symbol, color, x, y, size) {
            // Resolve the color from the CSS variable before using it with Canvas
            const resolvedColor = resolveCssVar(color);
            ctx.beginPath();
            ctx.arc(x + size / 2, y + size / 2, size / 2 - 5, 0, 2 * Math.PI);
            ctx.fillStyle = resolvedColor;
            ctx.fill();
            ctx.closePath();
            
            ctx.fillStyle = getContrastYIQ(color);
            ctx.font = '24px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(symbol, x + size / 2, y + size / 2);
        }
        
        function getContrastYIQ(hexcolor) {
            if (hexcolor.startsWith('var(')) {
                hexcolor = getComputedStyle(document.documentElement).getPropertyValue(hexcolor.match(/--[\w-]+/)[0]).trim();
            }
            const r = parseInt(hexcolor.substr(1, 2), 16);
            const g = parseInt(hexcolor.substr(3, 2), 16);
            const b = parseInt(hexcolor.substr(5, 2), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return (yiq >= 128) ? 'black' : 'white';
        }

        function dropElement(col) {
            if (isDropping || isMerging) return;
            if (grid[0][col] !== null) {
                showMessage('Column is full!');
                return;
            }

            isDropping = true;
            dropColumn = col;
            dropY = -CELL_SIZE;
            
            function animateDrop() {
                if (isDropping) {
                    dropY += DROP_SPEED * 5; // Faster drop
                    const targetY = findDropRow(col) * CELL_SIZE;

                    if (dropY >= targetY) {
                        isDropping = false;
                        const row = findDropRow(col);
                        grid[row][col] = activeElement;
                        activeElement = null;
                        
                        setTimeout(() => {
                            checkMerges();
                        }, 100);
                    } else {
                        requestAnimationFrame(animateDrop);
                    }
                }
            }
            requestAnimationFrame(animateDrop);
        }
        
        function findDropRow(col) {
            for (let r = GRID_ROWS - 1; r >= 0; r--) {
                if (grid[r][col] === null) {
                    return r;
                }
            }
            return -1; // Should not happen if check is done
        }

        function checkMerges() {
            isMerging = true;
            let mergedThisTurn = false;
            
            let allFoundGroups = [];
            const visited = new Set();
            
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (grid[r][c] && !visited.has(`${r},${c}`)) {
                        const group = findConnectedGroup(r, c);
                        allFoundGroups.push(group);
                        group.forEach(pos => visited.add(`${pos.r},${pos.c}`));
                    }
                }
            }

            // Check if any group matches a molecule
            for (const group of allFoundGroups) {
                const elementsInGroup = group.reduce((counts, pos) => {
                    const symbol = grid[pos.r][pos.c].symbol;
                    counts[symbol] = (counts[symbol] || 0) + 1;
                    return counts;
                }, {});

                for (const mol of molecules) {
                    const molElements = mol.elements;
                    let match = true;
                    // Check if group elements match molecule elements
                    for (const symbol in molElements) {
                        if (elementsInGroup[symbol] !== molElements[symbol]) {
                            match = false;
                            break;
                        }
                    }
                    // Check for extra elements in the group
                    for (const symbol in elementsInGroup) {
                        if (elementsInGroup[symbol] !== molElements[symbol]) {
                            match = false;
                            break;
                        }
                    }

                    if (match) {
                        mergeElements(group, mol);
                        mergedThisTurn = true;
                        break;
                    }
                }
            }
            
            if (mergedThisTurn) {
                setTimeout(() => {
                    checkMerges();
                }, ANIMATION_DURATION + 100); // Re-check after animation
            } else {
                isMerging = false;
                if (isGameOver()) {
                    showMessage('Game Over!');
                    newGameBtn.textContent = 'Play Again';
                } else {
                    generateNextElement();
                }
            }
        }

        function findConnectedGroup(startR, startC) {
            const group = [];
            const queue = [{ r: startR, c: startC }];
            const visited = new Set();
            visited.add(`${startR},${startC}`);

            while (queue.length > 0) {
                const { r, c } = queue.shift();
                group.push({ r, c });

                const neighbors = [
                    { r: r - 1, c: c },
                    { r: r + 1, c: c },
                    { r: r, c: c - 1 },
                    { r: r, c: c + 1 },
                ];

                for (const neighbor of neighbors) {
                    const { r: nextR, c: nextC } = neighbor;
                    if (nextR >= 0 && nextR < GRID_ROWS && nextC >= 0 && nextC < GRID_COLS &&
                        grid[nextR][nextC] !== null && !visited.has(`${nextR},${nextC}`)) {
                        visited.add(`${nextR},${nextC}`);
                        queue.push(neighbor);
                    }
                }
            }
            return group;
        }

        function mergeElements(group, molecule) {
            showMessage(`Merged: ${molecule.formula} (${molecule.name})! +${molecule.points}`);
            updateScore(molecule.points);
            updateTally(molecule.formula);
            playSound();
            
            // Animation for merging
            const centerR = group.reduce((sum, p) => sum + p.r, 0) / group.length;
            const centerC = group.reduce((sum, p) => sum + p.c, 0) / group.length;
            
            for (const pos of group) {
                const element = grid[pos.r][pos.c];
                if (element) {
                    const startX = pos.c * CELL_SIZE;
                    const startY = pos.r * CELL_SIZE;
                    const endX = centerC * CELL_SIZE;
                    const endY = centerR * CELL_SIZE;
                    
                    animateMerge(element, startX, startY, endX, endY);
                }
                grid[pos.r][pos.c] = null;
            }
        }

        function animateMerge(element, startX, startY, endX, endY) {
            const startTime = Date.now();
            function animate() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / ANIMATION_DURATION, 1);
                
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                
                // Draw a temporary element for the animation
                gameCtx.clearRect(currentX - 1, currentY - 1, CELL_SIZE + 2, CELL_SIZE + 2);
                drawElement(gameCtx, element.symbol, element.color, currentX, currentY, CELL_SIZE);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            requestAnimationFrame(animate);
        }

        function updateScore(points) {
            score += points;
            scoreDisplay.textContent = `Score: ${score}`;
        }
        
        function isGameOver() {
            for (let c = 0; c < GRID_COLS; c++) {
                if (grid[0][c] !== null) {
                    return true;
                }
            }
            return false;
        }
        
        function showMessage(msg) {
            messageBox.textContent = msg;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 1500);
        }

        // --- Event Listeners ---
        gameCanvas.addEventListener('click', (event) => {
            if (isDropping || isMerging || isGameOver()) return;
            const rect = gameCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const col = Math.floor(x / CELL_SIZE);
            
            if (col >= 0 && col < GRID_COLS) {
                activeElement = nextElement;
                nextElement = null; // Clear next element for a fresh one
                dropElement(col);
                generateNextElement();
            }
        });
        
        newGameBtn.addEventListener('click', () => {
            initGame();
            newGameBtn.textContent = 'New Game';
        });

        soundBtn.addEventListener('click', () => {
            soundOn = !soundOn;
            const icon = soundBtn.querySelector('i');
            icon.className = soundOn ? 'fas fa-volume-up' : 'fas fa-volume-mute';
        });

        // Start the game
        initGame();
    });
</script>

</body>
</html>
